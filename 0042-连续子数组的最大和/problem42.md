# 连续子数组的最大和
**定义状态：** dp[i]代表以nums[i]为结尾的连续子数组最大和  
**状态转移方程：**  若 dp[i-1] < 0，说明 dp[i - 1]对 dp[i] 产生负贡献，即 dp[i-1] + nums[i] 还不如nums[i] 本身大。所以状态转移方程为
```go
if dp[i-1] > 0 {
	dp[i] = dp[i-1] + nums[i]
} else {
	dp[i] = nums[i]
}
```
**初始状态：** dp[0] = nums[0], 以nums[0]为结尾的子数组的最大和  
**返回值：**  返回dp列表中的最大值，代表全局最大值。
### 空间复杂度优化
由于dp[i]只与dp[i-1]与nums[i]有关，所以可以将nums当作dp数组来用




